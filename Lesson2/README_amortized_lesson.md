# 📚 שיעור: ניתוח אמורטי (Amortized Analysis) – סיכום מלא + קוד
חבילה זו כוללת:
- `amortized_lesson.ipynb` — מחברת **Jupyter** עם הסברים בעברית + תאי קוד רצים.
- `amortized_lesson.py` — סקריפט **Python** עם הדגמות וגרפים.
- README זה — סיכום תמציתי + הוראות הרצה.

> מטרת השיעור: להבין למה פעולות שנראות יקרות לעיתים (O(n)) הן למעשה **O(1) בממוצע** לאורך סדרה ארוכה של פעולות.

---

## 🔎 תוכן לימודי (מהיר)
### 1) חזרה קצרה: סימונים אסימפטוטיים
- **O(g(n))** חסם עליון, **Ω(g(n))** חסם תחתון, **Θ(g(n))** שווה סדר־גודל.

### 2) Linked List (רשימה מקושרת)
- הוספה/מחיקה בתחילת/סוף — O(1)
- גישה לפי אינדקס — O(n)
- יתרון מול Array כשיש הרבה הוספות/מחיקות מקומיות.

### 3) ניתוח אמורטי – למה צריך?
כשפעולה לפעמים יקרה, אבל ברוב המקרים זולה, מודדים עלות **ממוצעת לפעולה** בסדרה של m פעולות.

שיטות מרכזיות:
- **Aggregate**: מחשבים עלות כוללת T(m), מציבים חסם C(m), ואז \(Amort = C(m)/m\).
- **Accounting**: גובים “מחיר קבוע” לכל פעולה ושומרים עודף למקרים היקרים.
- **Potential**: פונקציית פוטנציאל Φ המודדת “אנרגיה” שנאגרת במבנה (מתקדם).

### 4) דוגמאות אמורטיות
- **Binary Counter**: סה״כ היפוכי ביטים אחרי m אינקרמנטים < 2m ⇒ עלות אמורטית O(1).
- **Dynamic Array (append + resize ×2)**: אחת לכמה הוספות מתבצע העתקה גדולה, אבל העלות הכוללת עד m הוספות היא O(m) ⇒ אמורטית O(1).
- **Clearable Table (Lazy clear)**: מחיקת N תאים הופכת ל־O(1) פר תא בעזרת חותמות זמן / מיפוי “תקין” במקום איפוס פיזי.

---

## ▶️ איך מריצים
### אפשרות A — מחברת Jupyter
```bash
jupyter notebook amortized_lesson.ipynb
```

### אפשרות B — סקריפט Python
```bash
python amortized_lesson.py                 # מריץ הכול
python amortized_lesson.py --save-plots    # שומר גרפים בתיקיית out/
python amortized_lesson.py --section counter|dynamic|clear|all
```

תלויות:
```bash
pip install numpy matplotlib
```

---

## 🧠 טיפים ללמידה
- תריצו את התא → תסבירו לעצמכם במילים את הפלט → תשנו פרמטרים (m, factor) ותראו השפעה.
- אל תשכחו: ב־Aggregate *לא* מסתכלים על הפעולה הכי יקרה, אלא על **הסכום הכולל** T(m).

בהצלחה! ✨
