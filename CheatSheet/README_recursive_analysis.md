# ⏳ ניתוח אלגוריתמי ופתרון רקורסיבי

פרויקט זה מממש **פונקציה רקורסיבית** לחישוב **סכום הצמתים בעץ בינארי**,  
ומנתח את זמן הריצה שלה באמצעות **משפט האב (Master Theorem)**.

---

## 📘 סיכום שיעור – משפט האב (Master Theorem)

משפט האב קובע את זמן הריצה האסימפטוטי של רקורסיה מהצורה:

```
T(n) = a * T(n/b) + f(n)
```

כאשר:
- `a` – מספר הקריאות הרקורסיביות  
- `b` – יחס הקיטוע של הקלט בכל קריאה  
- `f(n)` – העבודה המקומית (מחוץ לקריאות הרקורסיביות)

ההשוואה נעשית בין `f(n)` לבין **הקובע הרקורסיבי** `n^(log_b a)`.

| 🔢 מקרה | 💡 מי "שולט" בזמן הריצה | ⏱️ פתרון T(n) |
|:-------:|:------------------------|:---------------|
| **1** | `f(n)` קטן פולינומיאלית מ־`n^(log_b a)` | `Θ(n^(log_b a))` |
| **2** | `f(n)` ≈ `n^(log_b a)` | `Θ(n^(log_b a) · log n)` |
| **3** | `f(n)` גדול פולינומיאלית מ־`n^(log_b a)` | `Θ(f(n))` |

---

## 🧩 שלבים לפתרון רקורסיבי – חישוב סכום עץ

כדי לממש ולנתח פונקציה רקורסיבית, יש לבצע שני שלבים עיקריים:

### 1️⃣ מקרה הבסיס (Base Case)

**מטרה:** להבטיח שהרקורסיה נעצרת  
**יישום:** אם הצומת הנוכחי הוא `None`, אין מה להוסיף לסכום – נחזיר `0`.

```python
if node is None:
    return 0
```

---

### 2️⃣ הצעד הרקורסיבי (Recursive Step)

**מטרה:** לפתור את הבעיה הנוכחית בעזרת פתרון של תתי-בעיות קטנות יותר  
**יישום:** סכום הערכים בתת-העצים השמאלי והימני, בתוספת הערך של הצומת הנוכחי.

```python
return (
    calculate_tree_sum(node.left) +
    calculate_tree_sum(node.right) +
    node.val
)
```

---

## 📈 ניתוח זמן ריצה של פונקציית סכום עץ

- **יחס רקורסיה:**  
  `T(n) = 2T(n/2) + Θ(1)`

- **ניתוח לפי משפט האב (מקרה 1):**  
  הקובע הרקורסיבי הוא `n^(log_2 2) = n`,  
  והוא שולט על `f(n) = Θ(1)`.

- **זמן ריצה סופי:**  
  `Θ(n)`

---

## 🌳 המחשה גרפית של מהלך הרקורסיה

```
        [10]
        /  \
     [5]   [3]
     / \     \
   [2] [7]   [1]

סכום כולל = 10 + 5 + 3 + 2 + 7 + 1 = 28
```

---

## 🧠 תובנות נוספות

- כל קריאה רקורסיבית מטפלת בתת-עץ שונה, ללא חפיפה.  
- כל צומת מבוקר בדיוק פעם אחת → סיבוכיות ליניארית.  
- זהו מבנה רקורסיבי קלאסי המשמש בבניית אלגוריתמים על עצים, גרפים ומבני נתונים רקורסיביים.
